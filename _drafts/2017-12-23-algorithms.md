---
layout: post
title: 算法
permalink: algorithms
---
会算法，才是区分程序员高下的分水岭。

因为程序员最大的目标就是用代码解决问题，而算法是方法论。所以，你可以会编程，但不一定能解决问题；但你能解决问题，就一定会编程。

早先的计算机科学家（那是还是数学家吧），已经把主要的问题总结了出来，并给出了具体解决方案，我们为什么不要这精华呢？

算法，是微观上的编码能力，那种小问题。而设计模式，是宏观上的架构。

一个程序员没有理由学不会算法呀。

所谓解决问题，就是把所有情况都考虑到，病给出每种情况的结果。

高级程序员不会把所有问题都在一个函数里解决，而是会用外部的力量，比如一个数组、一个包含更多信息的数据结构。解决问题，就要用到所有可以的条件来更好的完成任务。

算法的研究大部分时间其实是在纸上的，想明白了，编码是很快的。要擅于演算，用二维表等工具把过程推倒出来。而平时不需要纸的原因是因为过程不复杂，而高级程序员就是能解出复杂的问题。

作为不是算法工程师的软件工程师，用代码写算法时是有一个适应的，比如 Ruby：

- 用 Array.new(10, -1) 声明一个数组，它的 10 个元素都为 -1 。而在平时是直接使用的。
- 用 a.each_index, a.each_with_index 来遍历数组

# Merge Sort
光一个合并排序，就有很多能学到的：

- 递归
  - 停止条件
- 分制
  - 最小问题是什么
  - 如何划分成最小问题
  - 划分条件
  - 如何有序执行各个问题并得到结果
  - 如何合并结果
- 哨兵
- Array
- 复杂度： nlogn


# Longest Common Subsequence
动态规划，是为解决有最有子结构的问题。第 n 个问题总是能够通过第 n-1 个问题的解而解决。

相比贪心算法，动态规划的第 n 个问题依赖于 第 n-1 个问题，往往 n-1 时有多种情况，在 n 时选择最优的那个。

把当前情况和之前的最优解比较。其实动态规划遍历了所有的情况，并把之前的结果记录了下来，所有肯定能选出一个最优解啊！

那它为什么能做 O(mn) 内算出 LCS 呢？因为它根据先前条件，剪掉了好多没用的分支。虽然看最优解是用递归定义的。
