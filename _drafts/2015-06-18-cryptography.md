---
layout: post
title: 密码
---

在读《图解密码技术》，笔记。

平时我们使用的登录密码其实是pin或password，而这里的密码是cryptography，即安全传送消息的方法，通常包括密码算法和密钥等部分。

密码学家的六个重要工具：

* 对称密码
* 公钥密码
* 单向散列函数
* 消息认证码
* 数字签名
* 伪随机生成器

# 密码与信息安全常识

* 不用使用保密的密码算法
* 使用低强度的密码比不进行任何加密更危险
* 任何密码总有一天都会被破解
* 密码只是信息安全的一部分

# 对称密码（共享密钥密码）

## 异或（XOR）
听着名字很玄乎，其实算法就是相加。

* 0 xor 0 = 0
* 0 xor 1 = 1
* 1 xor 1 = 0
* 1 xor 0 = 1

而且符合加法的交互律和结合律。

在图形上理解就是反转了。硬币最开始都是正面0,反转一次是1,再反正就是0了又。

亦或的这种负负得正的性质很适合加解密。

## 一次性密码本加密

原理是将明文与一串随机的比特序列进行XOR运算。因为在暴力过程中，不仅会有明文出来，还会有其它类似明文的信息出来，从而无法判断哪一个才是正确的。

如加密的明文是“one”,暴力破解的结果中一定会有“one”出来，可是也会有“two”，“onl”等等。

* 密钥要和明文长度相等。
* 如何送密钥呢？用特工人员，所以不太实用。
* 虽然不实用，但思想会一直被用到。不就是密钥不好送吗，那我根据一个短的生成伪随机不就行了吗。太长？那我分组不就行了吗。

## DES
Data Encryption Standard，已经可以在有限时间内被暴力破解了，新的3DES也只能延长寿命。

其使用Feistel轮进行加密和解密。

## AES
Advanced Encryption Standard，取代DES的标准。

使用Rijndeal轮。

# 分组密码的模式

分组密码是每次只能处理特定长度的一块数据的一类密码算法。如DES分组长度是64 bit，AES可以是128 bit，192 bit或256 bit。而流密码对数据流进行连续处理，如一次密码本。

对分组密码算法迭代的方法就是模式。主要有:

  * ECB，Electronic CodeBook，电子密码本。每次的分组密钥相同。
  * CBC，Cipher Block Chaining，密码分组链接。将明文分组与前一个密文分组进行XOR生成分组密钥。推荐使用！
  * CFB，Cipher FeedBack，密码反馈。用相同分组密钥，把前一密文再加密，之后与明文XOR生成新的密文。
  * OFB，Output FeedBack，输出反馈。如上同样反馈，只是反回来的是密码算法的输出。
  * CTR，CounTeT，计数器。用相同的分组密钥，加密逐次累加的计数器生成密码，然后与明文XOR。推荐使用！

模式的名字即生成密文的方式，或生成密钥，如CBC。或使用相同的密钥，如ECB、CFB、OFB和CTR，生成了一次密码本里的密钥，在做XOR。然后对每块再进行DES或AES加密或解密。

这些模式是对一次性密码本加密的实用化。

* 伪随机生成密钥。
* 分组加解密。

# 公钥密码

终于到了神奇的非对称加密！

公钥密码(public-key cryptography)中，密钥分为加密密钥和解密密钥。它们不能单独生成。


## mod——模运算
和12的最大公约数为1的数（5、7、11），在数学上成为“和12互质的数”。

## RSA

在RSA中，明文、密钥和密文都是数字。

### 加密

> 密文 = 明文^E^ mod N

**求E次方的mod N。**

E和N的组合就是公钥。

### 解密

> 明文 = 密文^D^ mod N

**球D次方的mod N。**

D和N的组合就是私钥。

### 生成密钥对
即求E、D和N过程。

首先明白质数：质数（prime number）又称素数，是一个大于1的自然数，除了1和它本身外，不能被其他自然数整除。

* (1)求N

用伪随机数生成器求p和q，p和q都是质数。N = p * q

* (2)求L

L = lcm(p-1, q-1)    # L是p-1和q-1的最小公倍数。

* (3)求E

1 < E < L

gcd(E,L) = 1    # E和L的最大公约数为1（E和L互质）

* (4)求D

1 < D < L

E * D mod L = 1

按照以上过程，我们举个例子：

1. p=5,q=11: N=p*q = 55
2. L=lcm(p-1,q-1)=lcm(4,10) = 20
3. gcd(E,20) => E = 7
4. 7*D mod 20 = 1 => D = 3

所以这对密钥为E=7,D=3,N=55.

测试一下,明文为4,那么:

加密：rsa(4) = 4^7^ mod 55 = 16384 mod 55 = 49

解密：dersa(49) = 49^3^ mod 55 = 4

正确！

隐隐之中感觉到之所以能这么着，和mod的循环脱不了干系，看看那不停在转的时钟吧，“嘀嗒嘀嗒嘀嘀嗒，时钟它不不停在转动；嘀嗒嘀嗒嘀嘀嗒，小雨它拍打着水花...”

吐曹一下：小学一年级学的最小公倍数和最大公约数现在才用到！！！

# 混合密码系统

用RSA配送对称密码的密钥，明文用对称密码加密。

* 通过伪随机数生成器生成对称密码加密中使用的会话密钥。
* 用对称会话密钥加密消息。
* 用公钥密码加密会话密钥。
* 公钥来自于混合密码系统对外部。（即接收者发来的公钥）

会话密钥是对称密码的密钥，同时也是公钥密码的明文。

在这个系统中，接收者先将自己的公钥发给发送者，发送者按照上面过程加密，生成包含用公钥密码加密的会话密钥和用对称密码加密的消息的密文，发给接受者。

接受者收到密文后，将密文分离出加密的会话密钥和加密的消息，首先用私钥解密出会话密钥，然后用会话密钥解密加密的消息从而得到消息。

其中会话密钥是用伪随机数生成的，频率可以每次会话都换。

著名密码软件PGP、SSL/TLS都使用了混合密码系统。

# 单向散列函数——消息的“指纹”

单向散列函数（one-way hash function)有一个输入和一个输出，其中输入成为消息，输出称为散列值。

散列值的长度和消息的长度无关。无论消息是1 bit，还是100MB，甚至100GB，单向散列函数都会计算出固定长度的散列值。以SHA-1单向散列函数为例，它所计算的散列值的长度永远是160 bit（20字节）。

两个不同的消息产生同一个散列值的情况称为**碰撞**（collision）。

难以发现碰撞的性质称为**抗碰撞性**（collision resistance）。

MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512,这些都是常用的散列函数，其中MD4、MD5和SHA-1已早被攻破。

生成SHA-1的基本流程：

(1) 填充

对消息进行填充处理，使其长度为512 bit的整数倍。这里的512 bit为一个输入分组。

(2) 计算W,,0,, ~ W,,79,,

根据输入分组的512 bit计算出80个32 bit的值。

(3) 分组处理

对输入分组依次进行80个步骤的处理，计算出5个32 bit的值（A～E）作为SHA-1的内部状态。

(4) 单步处理

根据上面生成的所有（A～E）生成最终的160 bit散列值。


# 消息认证码

**消息认证码**（Message Authentication Code）是一种确认消息完整性并认证的技术。

MAC的输入包括任意长度的消息和一个发送者与接受者直接共享的密钥，它可以输出固定长度的数据，这个数据称为MAC值。

消息认证码是一种与密钥相关联的单向散列函数。密钥的配送可以使用公钥密码。

消息的完整性通过对消息生成MAC实现，消息的认证通过共享密钥实现，只有这两个输入都正确，才可以输出正确的MAC值。

# 数字签名

逻辑上它和公钥密码相反，签名者用私钥签名，认证者用公钥认证。在公钥密码里，私钥是用来解密，而公钥是用来加密发送的消息的。
这里的共是公开，私是私有，不管它们的功能是加密还是解密。

回顾公钥密码，组成密钥对的两个密钥之间存在严密的数学关系，无法拆散。用公钥加密的密文，只能用与改公钥配对的私钥才能解密。

使用RSA时，公钥私钥对，一方加密，另一方就可以解密。

数字签名的方法：

* 直接对消息签名
* 对消息的散列值签名

拿对消息的散列值签名说明签名的过程：

* 求消息的散列值
* 用私钥加密散列值生成签名
* 之后连同消息和签名一起发送（这里不保证消息的私密性）

那么如何验证签名呢？

* 接受者收到消息+签名
* 用相同的散列函数算法求得消息的散列值
* 对签名用签名者的公钥进行解密，也得到一个值
* 比较上两步得到的值，如果一样则验证了签名，否则是假签名

Android发布apk的签名就是对散列值签名。签了名后，就说明这个应用就是你独自的了，别人起相同的包名也不能够覆盖更新安装。

为了能够确定自己得到的公钥是否合法，我们需要使用证书。所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥。

# 证书

公钥证书（Public-Key Certificate, PKC）就像由权威机构发的VIP卡，有你的身份信息及属于你的公钥，并由**认证机构**（Certification Authority，CA）
加上数字签名。CA的签名如果公章，别人看到就应相信这里的内容。

公钥证书简称证书，主要内容有：

* 被认证人（或机构）的信息
* 被认证人（或机构）的公钥
* 认证机构的签名

这样当其他人接受到被认证人的证书时，首先用认证机构的公钥来核对认证机构的签名，正确的话说明证书里的内容是真的，然后就可以取出并使用被认证人的公钥了。

证书目前使用大多使用X.509规范，包括以下三部分内容：

* 签名前的证书——签名对象的信息
* 数字签名算法——对证书签名时所使用的算法
* 数字签名——对证书施加的数字签名

认证机构还有一个证书作废清单（Certificate Revocation List，CRL），当用户使用证书前，首先要下载最新的CRL来确定自己所使用的证书没有作废。

在我们的电子邮件软件和Web浏览器中，已经包含了一些有名的认证机构的证书，比如CNNIC的。


# 密钥

## Diffie-Hellman密钥交换
使用这种算法，通信双发仅通过交换一些可以公开的信息就能够生成出共享的秘密数字，而这一秘密数字就可以被用作对称密码的密钥。

## 基于口令的密码（PBE）

PBE，Password Based Encryption，根据口令生成密钥并用该密钥jinx加解密。

加密包括3个步骤：

### 1. 生成KEK
伪随机数生成器会生成一个被成为盐（salt）的随机数。将盐和输入的口令一起输入Hash函数，得到的散列值就是用来加密密钥的密钥（KEK）。

### 2. 生成会话密钥并加密
使用伪随机数生成器生成会话密钥。会话密钥是用来加密消息的密钥（CEK）。

CEK需要用1步骤中生成的KEK进行加密，并和盐一起保存在安全的地方。会话密码加密后，KEK就会被丢弃，因为它可以通过盐和口令算出来。

### 3. 加密消息
用上步生成的CEK加密消息。

可见，PBE加密后有3个输出：

* 盐
* 用KEK加密的会话密钥
* 用会话密钥加密的消息

这里盐的作用是用来防御字典攻击的。


因为使用的是对称密钥，所以解密的逻辑也很简单：

* 重建KEK
* 解密会话密钥
* 解密消息

# 伪随机数
随机数在密码技术中扮演着是否重要的角色：

* 生成密钥：用于对称密码和消息认证码。
* 生成密钥对：用于公钥密码和数字签名。
* 生成初始化向量（IV）：用于分组密码的CBC、CFB和OFB模式。
* 生成nonce：用于防御重放攻击以及分组密码的CTR模式等。
* 生成盐：用于基于口令的密码（PBE）等。

它有下面三个特点：

### 随机性 —— 不存在统计学偏差，是完全杂乱的数列。

### 不可预测性 —— 不能从过去的数列推测出下一个出现的数。

### 不可重现性 —— 除非将数列本身保存下来，否则不能重现相同的数列。
具备了这一性质，就是真随机数了。

但仅靠软件是无法生成具备不可重复性的随机数列的。软件只能生成伪随机数列，因为运行软件的计算机本身仅具备有限的内部状态。
而在内部状态相同的条件下，软件必然只能生成相同的数。

要生成具备不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音变化、手机的摇动、键盘的输入间隔等。

## 伪随机数生成器（Pseudo Random Number Generator，PRNG）
PRNG具有“内部状态”，根据外部输入的“种子”来生成伪随机数列。

生成PRNG的方法：

### 杂乱的方法
杂乱无章的算法实现，但再复杂也有周期短的缺陷，而且复杂到自己不能验证。

### 显性同余法

### 单向散列函数法

### 密码法

### ANSI X9.17
